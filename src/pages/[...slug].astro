---
/**
 * Dynamic Route Handler
 *
 * Layout Resolution:
 * - Config specifies: @docs/default, @blog/default, @custom/home
 * - Resolves to: layouts/{type}/styles/{style}/Layout.astro
 *
 * Standardized structure - no manual registry needed
 * Errors thrown if layout doesn't exist (no silent fallbacks)
 */
import BaseLayout from '@layouts/BaseLayout.astro';

import { loadSiteConfig, loadContent } from '@loaders/index';
import { getNavbarLayout, getFooterLayout } from '@loaders/config';

// Auto-discover all layouts using glob patterns (built-in + external)
const builtinDocsLayouts = import.meta.glob('/src/layouts/docs/styles/*/Layout.astro');
const extDocsLayouts = import.meta.glob('@ext-layouts/docs/styles/*/Layout.astro');

const builtinBlogIndexLayouts = import.meta.glob('/src/layouts/blogs/styles/*/IndexLayout.astro');
const extBlogIndexLayouts = import.meta.glob('@ext-layouts/blogs/styles/*/IndexLayout.astro');

const builtinBlogPostLayouts = import.meta.glob('/src/layouts/blogs/styles/*/PostLayout.astro');
const extBlogPostLayouts = import.meta.glob('@ext-layouts/blogs/styles/*/PostLayout.astro');

const builtinCustomLayouts = import.meta.glob('/src/layouts/custom/styles/*/Layout.astro');
const extCustomLayouts = import.meta.glob('@ext-layouts/custom/styles/*/Layout.astro');

const builtinNavbarLayouts = import.meta.glob('/src/layouts/navbar/*/index.astro');
const extNavbarLayouts = import.meta.glob('@ext-layouts/navbar/*/index.astro');

const builtinFooterLayouts = import.meta.glob('/src/layouts/footer/*/index.astro');
const extFooterLayouts = import.meta.glob('@ext-layouts/footer/*/index.astro');

/**
 * Merge built-in and external layout globs.
 * External entries override built-in with the same style name.
 */
function mergeLayouts(
  builtin: Record<string, () => Promise<any>>,
  ext: Record<string, () => Promise<any>>,
  stylePattern: RegExp,
) {
  const byStyle = new Map<string, { loader: () => Promise<any>; source: 'builtin' | 'external' }>();
  for (const [p, loader] of Object.entries(builtin)) {
    const m = p.match(stylePattern);
    if (m) byStyle.set(m[1], { loader, source: 'builtin' });
  }
  for (const [p, loader] of Object.entries(ext)) {
    const m = p.match(stylePattern);
    if (m) byStyle.set(m[1], { loader, source: 'external' });
  }
  return { byStyle, styles: [...byStyle.keys()] };
}

// Merged layout maps
const docsLayouts = mergeLayouts(builtinDocsLayouts, extDocsLayouts, /\/styles\/([^/]+)\//);
const blogIndexLayouts = mergeLayouts(builtinBlogIndexLayouts, extBlogIndexLayouts, /\/styles\/([^/]+)\//);
const blogPostLayouts = mergeLayouts(builtinBlogPostLayouts, extBlogPostLayouts, /\/styles\/([^/]+)\//);
const customLayouts = mergeLayouts(builtinCustomLayouts, extCustomLayouts, /\/styles\/([^/]+)\//);
const navbarLayouts = mergeLayouts(builtinNavbarLayouts, extNavbarLayouts, /\/navbar\/([^/]+)\//);
const footerLayouts = mergeLayouts(builtinFooterLayouts, extFooterLayouts, /\/footer\/([^/]+)\//);

// Available styles for error messages and dev toolbar validation
const availableDocsStyles = docsLayouts.styles;
const availableBlogStyles = blogIndexLayouts.styles;
const availableCustomStyles = customLayouts.styles;
const availableNavbarStyles = navbarLayouts.styles;
const availableFooterStyles = footerLayouts.styles;

export async function getStaticPaths() {
  const siteConfig = loadSiteConfig();
  const pages = siteConfig.pages || {};
  const paths: any[] = [];

  for (const [pageName, pageConfig] of Object.entries(pages)) {
    const baseUrl = pageConfig.base_url.replace(/^\//, '');
    const dataPath = pageConfig.data;
    const layout = pageConfig.layout || '';

    if (pageConfig.type === 'custom') {
      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'custom', layout },
      });
    } else if (pageConfig.type === 'docs') {
      const content = await loadContent(dataPath, 'docs', {
        pattern: '**/*.{md,mdx}',
        sort: 'position',
        requirePositionPrefix: true, // Docs require XX_ prefix for ordering
      });

      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'docs-index', allContent: content, layout },
      });

      for (const doc of content) {
        paths.push({
          params: { slug: `${baseUrl}/${doc.slug}` },
          props: { pageName, pageConfig, dataPath, pageType: 'docs', doc, allContent: content, layout },
        });
      }
    } else if (pageConfig.type === 'blog') {
      const posts = await loadContent(dataPath, 'blog', {
        pattern: '*.{md,mdx}',
        sort: 'date',
        order: 'desc',
      });

      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'blog-index', allContent: posts, layout },
      });

      for (const post of posts) {
        paths.push({
          params: { slug: `${baseUrl}/${post.slug}` },
          props: { pageName, pageConfig, dataPath, pageType: 'blog-post', post, layout },
        });
      }
    }
  }

  return paths;
}

// ============================================================================
// Page Rendering (validation happens here - errors show during build)
// ============================================================================

// In server mode, getStaticPaths() is ignored, so we compute props from URL
let { pageName, pageConfig, dataPath, pageType, doc, post, allContent, layout: configLayout } = Astro.props;

// Server mode: compute props dynamically if not provided by getStaticPaths
if (!pageType) {
  const slug = Astro.params.slug || '';

  // Skip internal routes (API endpoints)
  if (slug.startsWith('api/') || slug === 'api' || slug.startsWith('_')) {
    return new Response(null, { status: 404 });
  }

  const siteConfig = loadSiteConfig();
  const pages = siteConfig.pages || {};

  // Find matching page config based on URL
  for (const [name, config] of Object.entries(pages)) {
    const baseUrl = config.base_url.replace(/^\//, '');

    if (slug === baseUrl || slug.startsWith(baseUrl + '/')) {
      pageName = name;
      pageConfig = config;
      dataPath = config.data;
      configLayout = config.layout || '';

      if (config.type === 'custom') {
        pageType = 'custom';
      } else if (config.type === 'docs') {
        const content = await loadContent(dataPath, 'docs', {
          pattern: '**/*.{md,mdx}',
          sort: 'position',
          requirePositionPrefix: true,
        });
        allContent = content;

        if (slug === baseUrl) {
          pageType = 'docs-index';
        } else {
          const docSlug = slug.slice(baseUrl.length + 1);
          doc = content.find(d => d.slug === docSlug);
          pageType = 'docs';
        }
      } else if (config.type === 'blog') {
        const posts = await loadContent(dataPath, 'blog', {
          pattern: '*.{md,mdx}',
          sort: 'date',
          order: 'desc',
        });
        allContent = posts;

        if (slug === baseUrl) {
          pageType = 'blog-index';
        } else {
          const postSlug = slug.slice(baseUrl.length + 1);
          post = posts.find(p => p.slug === postSlug);
          pageType = 'blog-post';
        }
      }
      break;
    }
  }
}

// Dev mode: Allow layout override via cookie (set by dev toolbar)
// Any style in the respective styles/ folder is valid for that page type
const isDev = import.meta.env.DEV;
let layoutOverride: string | null = null;

if (isDev) {
  const layoutCookie = Astro.cookies.get('dev-layout');
  if (layoutCookie && layoutCookie.value && layoutCookie.value !== '__reset__') {
    layoutOverride = layoutCookie.value;
  }
}

// Determine effective layout - apply override only if it exists
let layout = configLayout;
if (layoutOverride && isDev) {
  if ((pageType === 'docs' || pageType === 'docs-index') && availableDocsStyles.includes(layoutOverride)) {
    layout = `@docs/${layoutOverride}`;
  } else if ((pageType === 'blog-index' || pageType === 'blog-post') && availableBlogStyles.includes(layoutOverride)) {
    layout = `@blog/${layoutOverride}`;
  }
  // Stale or invalid cookie values are silently ignored (use config)
}

// Get navbar/footer layouts from config
let navbarLayoutRef = getNavbarLayout();
let footerLayoutRef = getFooterLayout();

// Dev mode: Allow navbar/footer override via cookies (validate first)
if (isDev) {
  const navbarCookie = Astro.cookies.get('dev-navbar');
  if (navbarCookie?.value && navbarCookie.value !== '__reset__' && availableNavbarStyles.includes(navbarCookie.value)) {
    navbarLayoutRef = `@navbar/${navbarCookie.value}`;
  }

  const footerCookie = Astro.cookies.get('dev-footer');
  if (footerCookie?.value && footerCookie.value !== '__reset__' && availableFooterStyles.includes(footerCookie.value)) {
    footerLayoutRef = `@footer/${footerCookie.value}`;
  }
}

// Handle docs index redirect
if (pageType === 'docs-index' && allContent?.length > 0) {
  return Astro.redirect(`${pageConfig.base_url}/${allContent[0].slug}`);
}

/**
 * Validate and resolve layout - throws descriptive errors if not found
 */
function validateAndResolve(layoutAlias: string, variant?: 'index' | 'post') {
  if (!layoutAlias) {
    throw new Error(
      `\n[CONFIG ERROR] Missing 'layout' field for page "${pageName}".\n` +
      `  Add a layout field like: layout: "@docs/default"\n`
    );
  }

  const match = layoutAlias.match(/^@(\w+)\/(.+)$/);
  if (!match) {
    throw new Error(
      `\n[CONFIG ERROR] Invalid layout format: "${layoutAlias}"\n` +
      `  Expected format: @{type}/{style}\n` +
      `  Examples: @docs/default, @blog/default, @custom/home\n`
    );
  }

  const [, type, style] = match;
  let entry: { loader: () => Promise<any>; source: string } | undefined;
  let available: string[];

  if (type === 'docs') {
    entry = docsLayouts.byStyle.get(style);
    available = availableDocsStyles;

    if (!entry) {
      throw new Error(
        `\n[CONFIG ERROR] Docs layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/docs/styles/${style}/Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else if (type === 'blog') {
    available = availableBlogStyles;

    if (variant === 'index') {
      entry = blogIndexLayouts.byStyle.get(style);
    } else {
      entry = blogPostLayouts.byStyle.get(style);
    }

    if (!entry) {
      throw new Error(
        `\n[CONFIG ERROR] Blog layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/blogs/styles/${style}/${variant === 'index' ? 'Index' : 'Post'}Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else if (type === 'custom') {
    entry = customLayouts.byStyle.get(style);
    available = availableCustomStyles;

    if (!entry) {
      throw new Error(
        `\n[CONFIG ERROR] Custom layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/custom/styles/${style}/Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else {
    throw new Error(
      `\n[CONFIG ERROR] Unknown layout type: "${type}"\n` +
      `  Page: ${pageName}\n` +
      `  Config: ${layoutAlias}\n` +
      `  Valid types: docs, blog, custom\n`
    );
  }

  return entry.loader;
}

/**
 * Validate and resolve navbar/footer layout
 */
function resolveNavbarFooter(layoutAlias: string, type: 'navbar' | 'footer') {
  const match = layoutAlias.match(/^@(navbar|footer)\/(.+)$/);
  if (!match) {
    throw new Error(
      `\n[CONFIG ERROR] Invalid ${type} layout format: "${layoutAlias}"\n` +
      `  Expected format: @${type}/{style}\n` +
      `  Examples: @navbar/default, @footer/default\n`
    );
  }

  const [, , style] = match;
  const merged = type === 'navbar' ? navbarLayouts : footerLayouts;
  const available = type === 'navbar' ? availableNavbarStyles : availableFooterStyles;
  const entry = merged.byStyle.get(style);

  if (!entry) {
    throw new Error(
      `\n[CONFIG ERROR] ${type.charAt(0).toUpperCase() + type.slice(1)} layout "${style}" does not exist.\n` +
      `  Config: ${layoutAlias}\n` +
      `  Expected: src/layouts/${type}/${style}/index.astro\n` +
      `  Available: ${available.join(', ') || '(none)'}\n`
    );
  }

  return entry.loader;
}

// Resolve layout component
let LayoutComponent: any;

if (pageType === 'custom' || pageType === 'docs') {
  const loader = validateAndResolve(layout);
  LayoutComponent = (await loader()).default;
} else if (pageType === 'blog-index') {
  const loader = validateAndResolve(layout, 'index');
  LayoutComponent = (await loader()).default;
} else if (pageType === 'blog-post') {
  const loader = validateAndResolve(layout, 'post');
  LayoutComponent = (await loader()).default;
}

// Resolve navbar and footer components
const NavbarComponent = (await resolveNavbarFooter(navbarLayoutRef, 'navbar')()).default;
const FooterComponent = (await resolveNavbarFooter(footerLayoutRef, 'footer')()).default;

// Page title
let title = 'Page';
if (pageType === 'docs' && doc) title = doc.data.title;
else if (pageType === 'blog-post' && post) title = post.data.title;
else if (pageType === 'blog-index') title = 'Blog';

// Derive content type from page type for dev toolbar
let contentType: 'docs' | 'blog' | 'custom' | undefined;
if (pageType === 'docs' || pageType === 'docs-index') {
  contentType = 'docs';
} else if (pageType === 'blog-index' || pageType === 'blog-post') {
  contentType = 'blog';
} else if (pageType === 'custom') {
  contentType = 'custom';
}

// Layout props - always include baseUrl so sidebar builds correctly
let layoutProps: Record<string, any> = { dataPath, baseUrl: pageConfig?.base_url };

if (pageType === 'docs' && doc) {
  layoutProps = {
    title: doc.data.title,
    description: doc.data.description,
    dataPath,
    baseUrl: pageConfig.base_url,
    currentSlug: doc.slug,
    content: doc.content,
    headings: doc.headings, // Headings extracted during parsing
  };
} else if (pageType === 'docs' && !doc && pageConfig) {
  // Doc not found (possibly deleted) - still provide baseUrl for sidebar
  layoutProps = {
    title: 'Page Not Found',
    description: '',
    dataPath,
    baseUrl: pageConfig.base_url,
    currentSlug: '',
    content: '<p>This page does not exist or has been deleted.</p>',
    headings: [],
  };
} else if (pageType === 'blog-post' && post) {
  layoutProps = {
    title: post.data.title,
    description: post.data.description,
    date: post.data.date as string,
    author: post.data.author as string,
    tags: post.data.tags as string[],
    content: post.content,
  };
}
---

<BaseLayout title={title} contentType={contentType} editorPath={doc?.filePath || post?.filePath}>
  <NavbarComponent slot="navbar" />
  <LayoutComponent {...layoutProps} />
  <FooterComponent slot="footer" />
</BaseLayout>
