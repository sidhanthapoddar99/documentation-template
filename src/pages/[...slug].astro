---
/**
 * Dynamic Route Handler
 *
 * Layout Resolution:
 * - Config specifies: @docs/doc_style1, @blog/blog_style1, @custom/home
 * - Resolves to: layouts/{type}/styles/{style}/Layout.astro
 *
 * Standardized structure - no manual registry needed
 * Errors thrown if layout doesn't exist (no silent fallbacks)
 */
import BaseLayout from '@layouts/BaseLayout.astro';
import NavbarStyle1 from '@layouts/navbar/style1/index.astro';
import FooterDefault from '@layouts/footer/default/index.astro';

import { loadSiteConfig, loadContent } from '@loaders/index';
import { resolveAliasPath } from '@loaders/alias';

// Auto-discover all layouts using glob patterns
const docsLayouts = import.meta.glob('/src/layouts/docs/styles/*/Layout.astro');
const blogIndexLayouts = import.meta.glob('/src/layouts/blogs/styles/*/IndexLayout.astro');
const blogPostLayouts = import.meta.glob('/src/layouts/blogs/styles/*/PostLayout.astro');
const customLayouts = import.meta.glob('/src/layouts/custom/styles/*/Layout.astro');

// Available styles for error messages
const availableDocsStyles = Object.keys(docsLayouts).map(p => p.match(/\/styles\/([^/]+)\//)?.[1]).filter(Boolean);
const availableBlogStyles = Object.keys(blogIndexLayouts).map(p => p.match(/\/styles\/([^/]+)\//)?.[1]).filter(Boolean);
const availableCustomStyles = Object.keys(customLayouts).map(p => p.match(/\/styles\/([^/]+)\//)?.[1]).filter(Boolean);

export async function getStaticPaths() {
  const siteConfig = loadSiteConfig();
  const pages = siteConfig.pages || {};
  const paths: any[] = [];

  for (const [pageName, pageConfig] of Object.entries(pages)) {
    const baseUrl = pageConfig.base_url.replace(/^\//, '');
    const dataPath = resolveAliasPath(pageConfig.data);
    const layout = pageConfig.layout || '';

    if (pageConfig.type === 'custom') {
      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'custom', layout },
      });
    } else if (pageConfig.type === 'docs') {
      const content = await loadContent(dataPath, 'docs', {
        pattern: '**/*.{md,mdx}',
        sort: 'position',
        requirePositionPrefix: true, // Docs require XX_ prefix for ordering
      });

      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'docs-index', allContent: content, layout },
      });

      for (const doc of content) {
        paths.push({
          params: { slug: `${baseUrl}/${doc.slug}` },
          props: { pageName, pageConfig, dataPath, pageType: 'docs', doc, allContent: content, layout },
        });
      }
    } else if (pageConfig.type === 'blog') {
      const posts = await loadContent(dataPath, 'blog', {
        pattern: '*.{md,mdx}',
        sort: 'date',
        order: 'desc',
      });

      paths.push({
        params: { slug: baseUrl || undefined },
        props: { pageName, pageConfig, dataPath, pageType: 'blog-index', allContent: posts, layout },
      });

      for (const post of posts) {
        paths.push({
          params: { slug: `${baseUrl}/${post.slug}` },
          props: { pageName, pageConfig, dataPath, pageType: 'blog-post', post, layout },
        });
      }
    }
  }

  return paths;
}

// ============================================================================
// Page Rendering (validation happens here - errors show during build)
// ============================================================================

// In server mode, getStaticPaths() is ignored, so we compute props from URL
let { pageName, pageConfig, dataPath, pageType, doc, post, allContent, layout: configLayout } = Astro.props;

// Server mode: compute props dynamically if not provided by getStaticPaths
if (!pageType) {
  const slug = Astro.params.slug || '';

  // Skip internal routes (API endpoints)
  if (slug.startsWith('api') || slug.startsWith('_')) {
    return new Response(null, { status: 404 });
  }

  const siteConfig = loadSiteConfig();
  const pages = siteConfig.pages || {};

  // Find matching page config based on URL
  for (const [name, config] of Object.entries(pages)) {
    const baseUrl = config.base_url.replace(/^\//, '');

    if (slug === baseUrl || slug.startsWith(baseUrl + '/')) {
      pageName = name;
      pageConfig = config;
      dataPath = resolveAliasPath(config.data);
      configLayout = config.layout || '';

      if (config.type === 'custom') {
        pageType = 'custom';
      } else if (config.type === 'docs') {
        const content = await loadContent(dataPath, 'docs', {
          pattern: '**/*.{md,mdx}',
          sort: 'position',
          requirePositionPrefix: true,
        });
        allContent = content;

        if (slug === baseUrl) {
          pageType = 'docs-index';
        } else {
          const docSlug = slug.slice(baseUrl.length + 1);
          doc = content.find(d => d.slug === docSlug);
          pageType = 'docs';
        }
      } else if (config.type === 'blog') {
        const posts = await loadContent(dataPath, 'blog', {
          pattern: '*.{md,mdx}',
          sort: 'date',
          order: 'desc',
        });
        allContent = posts;

        if (slug === baseUrl) {
          pageType = 'blog-index';
        } else {
          const postSlug = slug.slice(baseUrl.length + 1);
          post = posts.find(p => p.slug === postSlug);
          pageType = 'blog-post';
        }
      }
      break;
    }
  }
}

// Dev mode: Allow layout override via cookie (set by dev toolbar)
// Layout overrides are type-specific: doc_style* for docs, blog_style* for blogs
const isDev = import.meta.env.DEV;
let layoutOverride: string | null = null;

if (isDev) {
  const layoutCookie = Astro.cookies.get('dev-layout');
  if (layoutCookie && layoutCookie.value && layoutCookie.value !== '__reset__') {
    layoutOverride = layoutCookie.value;
  }
}

// Determine effective layout - only apply override if it matches the page type
let layout = configLayout;
if (layoutOverride && isDev) {
  // Only apply override if the layout style matches the page type
  const isDocsLayout = layoutOverride.startsWith('doc_');
  const isBlogLayout = layoutOverride.startsWith('blog_');

  if ((pageType === 'docs' || pageType === 'docs-index') && isDocsLayout) {
    layout = `@docs/${layoutOverride}`;
  } else if ((pageType === 'blog-index' || pageType === 'blog-post') && isBlogLayout) {
    layout = `@blog/${layoutOverride}`;
  }
  // Custom pages don't have layout overrides (use config only)
}

// Handle docs index redirect
if (pageType === 'docs-index' && allContent?.length > 0) {
  return Astro.redirect(`${pageConfig.base_url}/${allContent[0].slug}`);
}

/**
 * Validate and resolve layout - throws descriptive errors if not found
 */
function validateAndResolve(layoutAlias: string, variant?: 'index' | 'post') {
  if (!layoutAlias) {
    throw new Error(
      `\n[CONFIG ERROR] Missing 'layout' field for page "${pageName}".\n` +
      `  Add a layout field like: layout: "@docs/doc_style1"\n`
    );
  }

  const match = layoutAlias.match(/^@(\w+)\/(.+)$/);
  if (!match) {
    throw new Error(
      `\n[CONFIG ERROR] Invalid layout format: "${layoutAlias}"\n` +
      `  Expected format: @{type}/{style}\n` +
      `  Examples: @docs/doc_style1, @blog/blog_style1, @custom/home\n`
    );
  }

  const [, type, style] = match;
  let loader: (() => Promise<any>) | undefined;
  let expectedPath: string;
  let available: string[];

  if (type === 'docs') {
    expectedPath = `/src/layouts/docs/styles/${style}/Layout.astro`;
    loader = docsLayouts[expectedPath];
    available = availableDocsStyles as string[];

    if (!loader) {
      throw new Error(
        `\n[CONFIG ERROR] Docs layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/docs/styles/${style}/Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else if (type === 'blog') {
    available = availableBlogStyles as string[];

    if (variant === 'index') {
      expectedPath = `/src/layouts/blogs/styles/${style}/IndexLayout.astro`;
      loader = blogIndexLayouts[expectedPath];
    } else {
      expectedPath = `/src/layouts/blogs/styles/${style}/PostLayout.astro`;
      loader = blogPostLayouts[expectedPath];
    }

    if (!loader) {
      throw new Error(
        `\n[CONFIG ERROR] Blog layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/blogs/styles/${style}/${variant === 'index' ? 'Index' : 'Post'}Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else if (type === 'custom') {
    expectedPath = `/src/layouts/custom/styles/${style}/Layout.astro`;
    loader = customLayouts[expectedPath];
    available = availableCustomStyles as string[];

    if (!loader) {
      throw new Error(
        `\n[CONFIG ERROR] Custom layout "${style}" does not exist.\n` +
        `  Page: ${pageName}\n` +
        `  Config: ${layoutAlias}\n` +
        `  Expected: src/layouts/custom/styles/${style}/Layout.astro\n` +
        `  Available: ${available.join(', ') || '(none)'}\n`
      );
    }
  } else {
    throw new Error(
      `\n[CONFIG ERROR] Unknown layout type: "${type}"\n` +
      `  Page: ${pageName}\n` +
      `  Config: ${layoutAlias}\n` +
      `  Valid types: docs, blog, custom\n`
    );
  }

  return loader;
}

// Resolve layout component
let LayoutComponent: any;

if (pageType === 'custom' || pageType === 'docs') {
  const loader = validateAndResolve(layout);
  LayoutComponent = (await loader()).default;
} else if (pageType === 'blog-index') {
  const loader = validateAndResolve(layout, 'index');
  LayoutComponent = (await loader()).default;
} else if (pageType === 'blog-post') {
  const loader = validateAndResolve(layout, 'post');
  LayoutComponent = (await loader()).default;
}

// Page title
let title = 'Page';
if (pageType === 'docs' && doc) title = doc.data.title;
else if (pageType === 'blog-post' && post) title = post.data.title;
else if (pageType === 'blog-index') title = 'Blog';

// Derive content type from page type for dev toolbar
let contentType: 'docs' | 'blog' | 'custom' | undefined;
if (pageType === 'docs' || pageType === 'docs-index') {
  contentType = 'docs';
} else if (pageType === 'blog-index' || pageType === 'blog-post') {
  contentType = 'blog';
} else if (pageType === 'custom') {
  contentType = 'custom';
}

// Layout props
let layoutProps: Record<string, any> = { dataPath };

if (pageType === 'docs' && doc) {
  // DEBUG: Log what we're passing
  console.log('[slug.astro DEBUG] pageConfig.base_url:', pageConfig?.base_url);
  console.log('[slug.astro DEBUG] pageName:', pageName);

  layoutProps = {
    title: doc.data.title,
    description: doc.data.description,
    dataPath,
    baseUrl: pageConfig.base_url,
    currentSlug: doc.slug,
    content: doc.content,
    headings: doc.headings, // Headings extracted during parsing
  };
} else if (pageType === 'blog-post' && post) {
  layoutProps = {
    title: post.data.title,
    description: post.data.description,
    date: post.data.date as string,
    author: post.data.author as string,
    tags: post.data.tags as string[],
    content: post.content,
  };
}
---

<BaseLayout title={title} contentType={contentType}>
  <NavbarStyle1 slot="navbar" />
  <LayoutComponent {...layoutProps} />
  <FooterDefault slot="footer" />
</BaseLayout>
