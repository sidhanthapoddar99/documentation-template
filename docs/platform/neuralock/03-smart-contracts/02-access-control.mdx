---
id: access-control
title: Access Control
description: Role-based access control system for Neuralock smart contracts
sidebar_position: 2
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/elements/Card';
import { Callout } from "@site/src/components/elements";
import { FileCollapsibleCodeBlock, FileInlineCodeCard } from '@site/src/components/elements/CodeBlock';
import { CustomMermaid } from '@site/src/components/elements';
import { MermaidDiagram } from '@site/src/components/elements';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import RoleHierarchySource from '!!raw-loader!./assets/role-hierarchy.mermaid';
import AccessControlFlowSource from '!!raw-loader!./assets/access-control-flow.mermaid';
import RoleManagementExample from '!!raw-loader!./assets/role-management-example.sol';

# Access Control

The Neuralock Access Control system implements a hierarchical role-based permission model that governs all administrative functions within the protocol.

## Overview

<Card className="card--primary">
  <CardHeader>
    <CardTitle>NeuralockAccessControl.sol</CardTitle>
    <CardDescription>
      Hierarchical role management with multi-owner support and granular permissions
    </CardDescription>
  </CardHeader>
  <ul>
    <li>**Three-tier hierarchy** - Owner → Admin → Manager</li>
    <li>**Multi-owner support** - Prevents single points of failure</li>
    <li>**Role inheritance** - Higher roles inherit lower permissions</li>
    <li>**Audit trail** - All role changes are logged on-chain</li>
  </ul>
</Card>

## Role Hierarchy

<MermaidDiagram 
  content={RoleHierarchySource}
  filename="role-hierarchy.mermaid"
  title="Role Hierarchy and Permissions"
  description="Complete role structure with inherited permissions"
/>

## Role Definitions

### Owner Role

<Card>
  <CardHeader>
    <CardTitle>System Owner</CardTitle>
    <CardDescription>Full control over the protocol</CardDescription>
  </CardHeader>
  
  **Capabilities:**
  - Grant/revoke any role (including other owners)
  - Upgrade contracts
  - Modify system parameters
  - Emergency functions (pause/unpause)
  - All admin and manager permissions
  
  **Best Practices:**
  - Use multi-signature wallets for owner addresses
  - Maintain multiple owners for redundancy
  - Time-lock critical operations
</Card>

### Admin Role

<Card>
  <CardHeader>
    <CardTitle>Administrator</CardTitle>
    <CardDescription>Server and manager administration</CardDescription>
  </CardHeader>
  
  **Capabilities:**
  - Add/remove managers
  - Mint/burn server NFTs
  - Modify non-critical parameters
  - All manager permissions
  
  **Cannot:**
  - Add/remove owners or admins
  - Upgrade contracts
  - Access emergency functions
</Card>

### Manager Role

<Card>
  <CardHeader>
    <CardTitle>Manager</CardTitle>
    <CardDescription>Day-to-day operational duties</CardDescription>
  </CardHeader>
  
  **Capabilities:**
  - Verify server metadata
  - Approve metadata updates
  - View all server information
  - Basic operational tasks
  
  **Cannot:**
  - Modify roles
  - Mint/burn NFTs without approval
  - Change system parameters
</Card>

## Implementation

### Role Storage Structure

<FileCollapsibleCodeBlock 
  content={`// Role definition with metadata
struct Role {
    bool isOwner;          // Owner privileges
    bool isAdmin;          // Admin privileges  
    bool isManager;        // Manager privileges
    uint256 assignedAt;    // Timestamp of assignment
    address assignedBy;    // Who assigned this role
}

// Role storage mapping
mapping(address => Role) public roles;

// Role counters for gas-efficient queries
uint256 public totalOwners;
uint256 public totalAdmins;
uint256 public totalManagers;

// Minimum owners requirement (prevents lockout)
uint256 public constant MIN_OWNERS = 1;`}
  filename="role-storage.sol"
  description="Role storage implementation"
/>

### Access Control Modifiers

<FileCollapsibleCodeBlock 
  content={`// Owner-only functions
modifier onlyOwner() {
    require(roles[msg.sender].isOwner, "AccessControl: Not an owner");
    _;
}

// Admin or higher
modifier onlyAdmin() {
    require(
        roles[msg.sender].isOwner || roles[msg.sender].isAdmin,
        "AccessControl: Not an admin"
    );
    _;
}

// Manager or higher
modifier onlyManager() {
    require(
        roles[msg.sender].isOwner || 
        roles[msg.sender].isAdmin || 
        roles[msg.sender].isManager,
        "AccessControl: Not a manager"
    );
    _;
}

// Specific role check
modifier onlyRole(uint8 requiredRole) {
    require(hasRole(msg.sender, requiredRole), "AccessControl: Missing role");
    _;
}`}
  filename="access-modifiers.sol"
  description="Access control modifiers"
/>

## Role Management Functions

<MermaidDiagram 
  content={AccessControlFlowSource}
  filename="access-control-flow.mermaid"
  title="Role Management Flow"
  description="Process flow for role assignment and revocation"
/>

### Complete Role Management Example

<FileCollapsibleCodeBlock 
  content={RoleManagementExample}
  filename="role-management-example.sol"
  description="Complete implementation of role management functions"
/>

## Multi-Owner Pattern

The system implements a robust multi-owner pattern to prevent single points of failure:

<Tabs>
<TabItem value="implementation" label="Implementation">

<FileCollapsibleCodeBlock 
  content={`// Prevent removing the last owner
function removeOwner(address account) external onlyOwner {
    require(roles[account].isOwner, "Not an owner");
    require(account != msg.sender, "Cannot remove self");
    require(totalOwners > MIN_OWNERS, "Cannot remove last owner");
    
    // Remove all roles
    delete roles[account];
    totalOwners--;
    
    // Also decrement other counters if applicable
    if (roles[account].isAdmin) totalAdmins--;
    if (roles[account].isManager) totalManagers--;
    
    emit OwnerRemoved(account, msg.sender);
}

// Transfer ownership (atomic operation)
function transferOwnership(address from, address to) external onlyOwner {
    require(roles[from].isOwner, "From is not an owner");
    require(!roles[to].isOwner, "To is already an owner");
    require(to != address(0), "Invalid address");
    
    // Atomic transfer
    roles[from].isOwner = false;
    roles[to] = Role({
        isOwner: true,
        isAdmin: roles[to].isAdmin,
        isManager: roles[to].isManager,
        assignedAt: block.timestamp,
        assignedBy: msg.sender
    });
    
    emit OwnerRemoved(from, msg.sender);
    emit OwnerAdded(to, msg.sender);
}`}
  filename="multi-owner.sol"
  description="Multi-owner implementation"
/>

</TabItem>
<TabItem value="bestpractices" label="Best Practices">

<Callout type="success" title="Multi-Owner Best Practices">

1. **Minimum 3 Owners**: Maintain at least 3 owners for redundancy
2. **Geographic Distribution**: Owners in different time zones
3. **Multi-Sig Wallets**: Use Gnosis Safe or similar for owner addresses
4. **Regular Audits**: Review owner list quarterly
5. **Emergency Procedures**: Document owner replacement process

</Callout>

<Callout type="warning" title="Security Considerations">

- Never use EOAs (Externally Owned Accounts) for production owners
- Implement time-locks for owner additions/removals
- Consider requiring multiple owners to approve owner changes
- Keep secure backups of all owner keys

</Callout>

</TabItem>
</Tabs>

## Emergency Access Control

<Card className="card--elevated">
  <CardHeader>
    <CardTitle>Emergency Functions</CardTitle>
    <CardDescription>Circuit breakers and emergency procedures</CardDescription>
  </CardHeader>

<FileCollapsibleCodeBlock 
  content={`// Pause mechanism for emergencies
bool public paused;

modifier whenNotPaused() {
    require(!paused, "Contract is paused");
    _;
}

function pause() external onlyOwner {
    paused = true;
    emit Paused(msg.sender);
}

function unpause() external onlyOwner {
    paused = false;
    emit Unpaused(msg.sender);
}

// Emergency withdrawal (owner only)
function emergencyWithdraw(address token, uint256 amount) 
    external 
    onlyOwner 
{
    if (token == address(0)) {
        // Withdraw ETH
        payable(msg.sender).transfer(amount);
    } else {
        // Withdraw ERC20
        IERC20(token).transfer(msg.sender, amount);
    }
    
    emit EmergencyWithdrawal(token, amount, msg.sender);
}`}
  filename="emergency-access.sol"
  description="Emergency access control functions"
/>

</Card>

## Query Functions

Efficient functions for querying role information:

<FileCollapsibleCodeBlock 
  content={`// Check if address has specific role
function hasRole(address account, uint8 role) public view returns (bool) {
    if (role == OWNER_ROLE) return roles[account].isOwner;
    if (role == ADMIN_ROLE) return roles[account].isAdmin || roles[account].isOwner;
    if (role == MANAGER_ROLE) {
        return roles[account].isManager || 
               roles[account].isAdmin || 
               roles[account].isOwner;
    }
    return false;
}

// Get all roles for an address
function getRoles(address account) external view returns (
    bool isOwner,
    bool isAdmin,
    bool isManager,
    uint256 assignedAt,
    address assignedBy
) {
    Role memory role = roles[account];
    return (
        role.isOwner,
        role.isAdmin,
        role.isManager,
        role.assignedAt,
        role.assignedBy
    );
}

// Get list of all addresses with specific role
function getRoleMembers(uint8 role) external view returns (address[] memory) {
    // Implementation depends on whether you maintain role member lists
    // This is a gas-intensive operation if iterating through all addresses
}`}
  filename="query-functions.sol"
  description="Role query functions"
/>

## Events and Logging

All role changes emit events for transparency and off-chain monitoring:

<FileCollapsibleCodeBlock 
  content={`// Role assignment events
event OwnerAdded(address indexed account, address indexed by);
event OwnerRemoved(address indexed account, address indexed by);
event AdminAdded(address indexed account, address indexed by);
event AdminRemoved(address indexed account, address indexed by);
event ManagerAdded(address indexed account, address indexed by);
event ManagerRemoved(address indexed account, address indexed by);

// Emergency events
event Paused(address indexed by);
event Unpaused(address indexed by);
event EmergencyWithdrawal(
    address indexed token, 
    uint256 amount, 
    address indexed by
);

// Generic role event for extensibility
event RoleModified(
    address indexed account,
    string indexed role,
    bool indexed granted,
    address by
);`}
  filename="access-control-events.sol"
  description="Access control events"
/>

## Integration with Registry

The access control system is tightly integrated with the registry contract:

<FileCollapsibleCodeBlock 
  content={`contract NeuralockRegistry is 
    ERC721, 
    NeuralockAccessControl, 
    ReentrancyGuard 
{
    // Mint function using role modifiers
    function mintServer(address to, ServerMetadata memory metadata)
        external
        onlyManager  // From AccessControl
        whenNotPaused  // From AccessControl
        nonReentrant
        returns (uint256)
    {
        // Minting logic
    }
    
    // Admin function to set parameters
    function setVerificationThreshold(uint256 threshold)
        external
        onlyAdmin  // From AccessControl
    {
        require(threshold > 0 && threshold <= totalManagers, "Invalid threshold");
        verificationThreshold = threshold;
        emit VerificationThresholdUpdated(threshold);
    }
    
    // Owner function for upgrades
    function upgradeToAndCall(address newImplementation, bytes memory data)
        external
        onlyOwner  // From AccessControl
    {
        _authorizeUpgrade(newImplementation);
        _upgradeToAndCallUUPS(newImplementation, data, true);
    }
}`}
  filename="registry-integration.sol"
  description="Access control integration with registry"
/>

## Security Best Practices

<Callout type="info" title="Implementation Guidelines">

### Role Assignment
1. **Verify addresses** before granting roles
2. **Use multi-sig** for critical role assignments
3. **Document** all role holders off-chain
4. **Regular audits** of role assignments

### Access Control Patterns
```solidity
// Good: Explicit role checking
function criticalFunction() external onlyOwner { }

// Bad: Implicit trust
function criticalFunction() external {
    // Assuming msg.sender is authorized
}

// Good: Fail-safe defaults
bool public systemEnabled = false;  // Explicit opt-in

// Bad: Fail-open defaults  
bool public systemDisabled = false;  // Dangerous default
```

### Monitoring
- Set up event monitors for all role changes
- Alert on unexpected role modifications
- Track failed authorization attempts
- Regular review of access logs

</Callout>

## Common Patterns

### Timelock for Critical Operations

<FileCollapsibleCodeBlock 
  content={`mapping(bytes32 => uint256) public timelocks;
uint256 public constant TIMELOCK_DURATION = 48 hours;

function proposeRoleChange(address account, uint8 role) 
    external 
    onlyOwner 
    returns (bytes32) 
{
    bytes32 id = keccak256(abi.encodePacked(account, role, block.timestamp));
    timelocks[id] = block.timestamp + TIMELOCK_DURATION;
    
    emit RoleChangeProposed(id, account, role);
    return id;
}

function executeRoleChange(bytes32 id, address account, uint8 role) 
    external 
    onlyOwner 
{
    require(timelocks[id] != 0, "No pending change");
    require(block.timestamp >= timelocks[id], "Timelock not expired");
    
    // Execute role change
    if (role == OWNER_ROLE) _addOwner(account);
    else if (role == ADMIN_ROLE) _addAdmin(account);
    // ... etc
    
    delete timelocks[id];
    emit RoleChangeExecuted(id, account, role);
}`}
  filename="timelock-pattern.sol"
  description="Timelock pattern for critical operations"
/>

### Role-Based Function Registry

<FileCollapsibleCodeBlock 
  content={`// Map function selectors to required roles
mapping(bytes4 => uint8) public functionRoles;

function setFunctionRole(bytes4 selector, uint8 role) 
    external 
    onlyOwner 
{
    functionRoles[selector] = role;
}

modifier requiresRole(bytes4 selector) {
    uint8 requiredRole = functionRoles[selector];
    require(hasRole(msg.sender, requiredRole), "Insufficient role");
    _;
}

// Usage
function someFunction() 
    external 
    requiresRole(this.someFunction.selector) 
{
    // Function logic
}`}
  filename="function-registry.sol"
  description="Dynamic role-based function access"
/>

## Next Steps

- Understand the [Integration Interface](./03-integration-interface) for applications
- Learn about [Deployment](./04-deployment-guide) with proper access control
- Review [Registry Contract](./01-registry-contract) role usage