---
id: how-it-works
title: How Neuralock Works
description: Step-by-step walkthrough of the Neuralock protocol and operations
sidebar_position: 3
---

import Code1 from '!!raw-loader!./assets/03-how-it-works/ephemeral-keypair-generation.ts';
import Code2 from '!!raw-loader!./assets/03-how-it-works/session-request-creation.ts';
import Code3 from '!!raw-loader!./assets/03-how-it-works/encryption-key-generation.ts';
import Code4 from '!!raw-loader!./assets/03-how-it-works/data-encryption.ts';
import Code5 from '!!raw-loader!./assets/03-how-it-works/key-splitting-shamir.ts';
import Code6 from '!!raw-loader!./assets/03-how-it-works/share-encryption-for-servers.ts';
import Code7 from '!!raw-loader!./assets/03-how-it-works/permission-verification-contract.sol';
import Code8 from '!!raw-loader!./assets/03-how-it-works/server-share-reencryption.ts';
import Code9 from '!!raw-loader!./assets/03-how-it-works/client-share-decryption.ts';
import Code10 from '!!raw-loader!./assets/03-how-it-works/aes-decryption.ts';
import Code11 from '!!raw-loader!./assets/03-how-it-works/batch-encryption.ts';
import Code12 from '!!raw-loader!./assets/03-how-it-works/streaming-encryption.ts';
import Code13 from '!!raw-loader!./assets/03-how-it-works/constant-time-comparison.ts';
import Code14 from '!!raw-loader!./assets/03-how-it-works/rate-limiting-config.ts';
import Code15 from '!!raw-loader!./assets/03-how-it-works/audit-log-format.json';
import Code16 from '!!raw-loader!./assets/03-how-it-works/client-cache-with-ttl.ts';
import Code17 from '!!raw-loader!./assets/03-how-it-works/server-cache-implementation.py';
import Code18 from '!!raw-loader!./assets/03-how-it-works/connection-pool-management.ts';

import { Card, CardHeader, CardTitle } from "@site/src/components/elements";
import { Callout } from "@site/src/components/elements";
import { MermaidDiagram } from '@site/src/components/elements';
import { CustomMermaid } from '@site/src/components/elements';
import { CollapsibleCodeBlock } from '@site/src/components/elements';
import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import EncryptionFlowSource from '!!raw-loader!./assets/encryption-flow.mermaid';
import DecryptionFlowSource from '!!raw-loader!./assets/decryption-flow.mermaid';
import SessionFlowSource from '!!raw-loader!./assets/session-flow.mermaid';

# How Neuralock Works

This guide provides a detailed walkthrough of how Neuralock operates, from initial setup through encryption and decryption processes.

## Overview

Neuralock operates through a carefully orchestrated sequence of cryptographic operations and blockchain verifications. The process ensures that:

1. **No single entity** can access encrypted data
2. **Permissions are verified** on-chain before any operation
3. **Keys are never exposed** in their complete form
4. **Sessions are ephemeral** to minimize exposure

## Session Establishment

Before any encryption or decryption can occur, clients must establish a session with the Neuralock network.

<MermaidDiagram 
  content={SessionFlowSource}
  filename="session-flow.mermaid"
  title="Session Establishment Flow"
  description="Complete process of creating a session with the Neuralock network"
/>

### Step 1: Generate Ephemeral Keypair

<CollapsibleCodeBlock content={Code1} filename="ephemeral-keypair-generation.ts" />

<Callout type="info">
  Ephemeral keypairs are unique to each session and discarded after the session expires, providing perfect forward secrecy.
</Callout>

### Step 2: Create Signed Message

The client creates a message proving ownership of their blockchain address:

<CollapsibleCodeBlock content={Code2} filename="session-request-creation.ts" />

### Step 3: Register with Servers

The client sends the session request to all configured servers:

<CodeBlock language="typescript">
{`// Contact all servers in parallel
const sessionPromises = servers.map(server => 
  fetch(\`\${server.endpoint}/session\`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      message,
      signature,
      ephemeralPublicKey
    })
  })
);

// Wait for responses
const responses = await Promise.allSettled(sessionPromises);
const successful = responses.filter(r => r.status === 'fulfilled');

if (successful.length < threshold) {
  throw new Error('Insufficient servers available');
}`}</CodeBlock>

### Step 4: Server Verification

Each server performs several verification steps:

<CustomMermaid 
  value={`sequenceDiagram
    participant Client
    participant Server
    participant Blockchain
    
    Client->>Server: Session Request
    Server->>Server: Verify signature
    Server->>Blockchain: Check address exists
    Blockchain-->>Server: Address confirmed
    Server->>Server: Generate session ID
    Server->>Server: Store session data
    Server-->>Client: Session created
    
    Note over Server: Session data includes:<br/>- Session ID<br/>- Ephemeral public key<br/>- Expiry time<br/>- User address`}
/>

## Encryption Process

Once a session is established, clients can encrypt data using the Neuralock network.

<MermaidDiagram 
  content={EncryptionFlowSource}
  filename="encryption-flow.mermaid"
  title="Data Encryption Flow"
  description="Step-by-step encryption process with threshold key distribution"
/>

### Step 1: Generate Encryption Key

<CollapsibleCodeBlock content={Code3} filename="encryption-key-generation.ts" />

### Step 2: Encrypt Data

<CollapsibleCodeBlock content={Code4} filename="data-encryption.ts" />

### Step 3: Split the Key

Using Shamir's Secret Sharing, the AES key is split into shares:

<CollapsibleCodeBlock content={Code5} filename="key-splitting-shamir.ts" />

<Callout type="info" title="Shamir's Secret Sharing Mathematics">
  The algorithm creates a polynomial of degree (k-1) where:
  - The secret is the constant term (at x=0)
  - Each share is a point on the polynomial
  - k points are needed to reconstruct the polynomial
</Callout>

### Step 4: Encrypt Shares for Servers

Each share is encrypted using ECDH with the respective server's public key:

<CollapsibleCodeBlock content={Code6} filename="share-encryption-for-servers.ts" />

### Step 5: Store Shares on Servers

<CustomMermaid 
  value={`sequenceDiagram
    participant Client
    participant Server
    participant SmartContract
    participant Storage
    
    Client->>Server: Store encrypted share
    Server->>Server: Validate session
    Server->>SmartContract: Check write permission
    SmartContract-->>Server: Permission granted
    Server->>Server: Decrypt share with ECDH
    Server->>Server: Re-encrypt for storage
    Server->>Storage: Store encrypted share
    Storage-->>Server: Confirmation
    Server-->>Client: Share stored
    
    Note over Server: Share stored with:<br/>- Object ID<br/>- User address<br/>- Timestamp<br/>- Encrypted data`}
/>

### Step 6: Permission Verification

Servers verify permissions before storing shares:

<CollapsibleCodeBlock content={Code7} filename="permission-verification-contract.sol" />

## Decryption Process

Decryption reverses the encryption process, but with additional permission checks.

<MermaidDiagram 
  content={DecryptionFlowSource}
  filename="decryption-flow.mermaid"
  title="Data Decryption Flow"
  description="Process of retrieving and reconstructing encrypted data"
/>

### Step 1: Request Shares

<CodeBlock language="typescript">
{`// Request shares from servers
const shareRequests = servers.map(server =>
  fetch(\`\${server.endpoint}/shares/\${objectId}\`, {
    method: 'GET',
    headers: {
      'X-Session-ID': sessionId,
      'X-Timestamp': Date.now(),
      'X-Signature': await signRequest(...)
    }
  })
);

// Collect responses
const responses = await Promise.allSettled(shareRequests);
const validShares = responses
  .filter(r => r.status === 'fulfilled')
  .map(r => r.value);`}</CodeBlock>

### Step 2: Server Permission Check

Each server independently verifies read permissions:

<CustomMermaid 
  value={`flowchart TD
    A[Receive Request] --> B{Valid Session?}
    B -->|No| C[Reject: 401]
    B -->|Yes| D[Check Blockchain]
    D --> E{Read Permission?}
    E -->|No| F[Reject: 403]
    E -->|Yes| G[Retrieve Share]
    G --> H[Re-encrypt for Session]
    H --> I[Return Share]
    
    style C fill:#ffcccc
    style F fill:#ffcccc
    style I fill:#ccffcc`}
/>

### Step 3: Share Re-encryption

Servers re-encrypt shares using the session's ephemeral key:

<CollapsibleCodeBlock content={Code8} filename="server-share-reencryption.ts" />

### Step 4: Decrypt Shares

The client decrypts the received shares:

<CollapsibleCodeBlock content={Code9} filename="client-share-decryption.ts" />

### Step 5: Reconstruct the Key

Using Lagrange interpolation, reconstruct the original AES key:

<CodeBlock language="typescript">
{`// Need at least threshold shares
if (decryptedShares.length < threshold) {
  throw new Error(
    \`Insufficient shares: ${decryptedShares.length}/${threshold}\`
  );
}

// Reconstruct using Shamir's algorithm
const reconstructedKey = shamirCombine(
  decryptedShares.slice(0, threshold)
);

// Import as CryptoKey
const aesKey = await crypto.subtle.importKey(
  'raw',
  reconstructedKey,
  { name: 'AES-GCM' },
  false,
  ['decrypt']
);`}</CodeBlock>

### Step 6: Decrypt Data

Finally, decrypt the original data:

<CollapsibleCodeBlock content={Code10} filename="aes-decryption.ts" />

## Advanced Operations

### Batch Operations

For efficiency, multiple operations can be batched:

<CollapsibleCodeBlock content={Code11} filename="batch-encryption.ts" />

### Streaming Operations

For large files, streaming encryption is supported:

<CollapsibleCodeBlock content={Code12} filename="streaming-encryption.ts" />

### Key Rotation

Periodic key rotation enhances security:

<CustomMermaid 
  value={`sequenceDiagram
    participant Client
    participant Servers
    participant Blockchain
    
    Client->>Servers: Request current shares
    Servers-->>Client: Return encrypted shares
    Client->>Client: Decrypt and reconstruct key
    Client->>Client: Decrypt data
    Client->>Client: Generate new key
    Client->>Client: Re-encrypt data
    Client->>Client: Split new key
    Client->>Servers: Store new shares
    Servers->>Blockchain: Log rotation event
    Client->>Servers: Delete old shares`}
/>

## Security Considerations

### Timing Attack Prevention

All cryptographic operations use constant-time implementations:

<CollapsibleCodeBlock content={Code13} filename="constant-time-comparison.ts" />

### Rate Limiting

Servers implement rate limiting to prevent abuse:

<CollapsibleCodeBlock content={Code14} filename="rate-limiting-config.ts" />

### Audit Logging

All operations are logged for security auditing:

<CollapsibleCodeBlock content={Code15} filename="audit-log-format.json" />

## Performance Optimization

### Caching Strategies

<Tabs>
<TabItem value="client" label="Client-Side">

<CollapsibleCodeBlock content={Code16} filename="client-cache-with-ttl.ts" />

</TabItem>
<TabItem value="server" label="Server-Side">

<CollapsibleCodeBlock content={Code17} filename="server-cache-implementation.py" />

</TabItem>
</Tabs>

### Connection Pooling

Efficient connection management:

<CollapsibleCodeBlock content={Code18} filename="connection-pool-management.ts" />

## Summary

Neuralock's operation can be summarized in these key steps:

1. **Session Creation**: Establish ephemeral identity with the network
2. **Data Encryption**: Encrypt locally with AES-256
3. **Key Distribution**: Split and distribute key shares using Shamir's Secret Sharing
4. **Permission Verification**: On-chain validation before any operation
5. **Secure Storage**: Encrypted shares stored across multiple servers
6. **Threshold Reconstruction**: Minimum k servers required for decryption

This design ensures that:
- ✅ No single point of failure exists
- ✅ Data remains encrypted end-to-end
- ✅ Permissions are cryptographically enforced
- ✅ System remains available even with server failures
- ✅ Perfect forward secrecy through ephemeral sessions

## Next Steps

- **[Key Features](/neuralock/overview/key-features)** - Explore Neuralock's capabilities
- **[Quick Start Guide](/neuralock/getting-started/quick-start)** - Begin implementation
- **[API Reference](/neuralock/api/reference)** - Detailed API documentation