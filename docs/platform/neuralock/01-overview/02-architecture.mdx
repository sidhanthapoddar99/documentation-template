---
id: architecture
title: System Architecture
description: Deep dive into Neuralock's distributed architecture and components
sidebar_position: 2
---

import { Card, CardHeader, CardTitle } from "@site/src/components/elements";
import { Callout } from "@site/src/components/elements";
import { Features, Feature } from '@site/src/components/elements/Features';
import { MermaidDiagram } from '@site/src/components/elements';
import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import SystemArchitectureSource from '!!raw-loader!./assets/system-architecture.mermaid';
import ComponentFlowSource from '!!raw-loader!./assets/component-flow.mermaid';

# System Architecture

Neuralock implements a distributed threshold encryption system through five interconnected layers, each serving a specific purpose in the secure management of encrypted data.

## Architecture Overview

<MermaidDiagram 
  content={SystemArchitectureSource}
  filename="system-architecture.mermaid"
  title="Neuralock System Architecture"
  description="Complete system architecture showing all layers and their interactions"
/>

## Core Components

### 1. Smart Contract Layer

The blockchain layer provides the foundation for access control and server registry management.

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
  <Card>
    <CardHeader>
      <CardTitle>NeuralockRegistry.sol</CardTitle>
    </CardHeader>
    <p><strong>Purpose:</strong> NFT-based server identification and management</p>
    <ul>
      <li>Mints NFTs for server registration</li>
      <li>Manages server metadata and public keys</li>
      <li>Implements role-based access control</li>
      <li>Tracks server importance factors</li>
    </ul>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>INeuralock Interface</CardTitle>
    </CardHeader>
    <p><strong>Purpose:</strong> Standard interface for application integration</p>
    <ul>
      <li>Defines permission checking methods</li>
      <li>Ensures consistent access control</li>
      <li>Enables composability with other contracts</li>
      <li>Supports upgradeable implementations</li>
    </ul>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Application Contracts</CardTitle>
    </CardHeader>
    <p><strong>Purpose:</strong> Custom access logic for specific use cases</p>
    <ul>
      <li>Implement domain-specific permissions</li>
      <li>Define object ownership rules</li>
      <li>Handle time-based access</li>
      <li>Support multi-signature approvals</li>
    </ul>
  </Card>
</div>

<CodeBlock language="solidity">
{`// Core interface that all application contracts must implement
interface INeuralock {
    // Returns access level: 0=None, 1=Read, 2=Write, 3=Read+Write
    function neuralock(address user, bytes32 objectId) 
        external view returns (uint8);
}

// Example implementation for document management
contract DocumentVault is INeuralock {
    mapping(bytes32 => address) public documentOwners;
    mapping(bytes32 => mapping(address => uint8)) public permissions;
    
    function neuralock(address user, bytes32 objectId) 
        external view override returns (uint8) {
        if (documentOwners[objectId] == user) {
            return 3; // Full access for owner
        }
        return permissions[objectId][user];
    }
}`}</CodeBlock>

### 2. Server Network

The distributed server network forms the backbone of Neuralock's security model.

<MermaidDiagram 
  content={ComponentFlowSource}
  filename="component-flow.mermaid"
  title="Server Component Flow"
  description="Internal architecture of a Neuralock server node"
/>

#### Server Components

<Features>
  <Feature 
    icon="ðŸ”‘" 
    title="Key Management" 
    description="Secure generation and storage of server encryption keys using secp256k1 and X25519"
  />
  <Feature 
    icon="ðŸ“¡" 
    title="API Layer" 
    description="RESTful endpoints for session management, encryption, and decryption operations"
  />
  <Feature 
    icon="ðŸ’¾" 
    title="Storage Layer" 
    description="LevelDB for persistent share storage, Redis for ephemeral session data"
  />
  <Feature 
    icon="ðŸ”" 
    title="Cryptographic Engine" 
    description="Handles ECDH key agreement, AES encryption, and Shamir's Secret Sharing"
  />
  <Feature 
    icon="â›“ï¸" 
    title="Blockchain Client" 
    description="Verifies permissions and server registry status on-chain"
  />
  <Feature 
    icon="ðŸ“Š" 
    title="Monitoring" 
    description="Health checks, performance metrics, and security event logging"
  />
</Features>

#### Server Deployment Modes

<Tabs>
<TabItem value="single" label="Single Server (Development)">

Perfect for testing and development environments:

```yaml
# docker-compose.yml for single server setup
version: '3.8'
services:
  neuralock-server:
    image: neuralock/server:latest
    environment:
      - MODE=single
      - THRESHOLD=1
      - TOTAL_SERVERS=1
      - BLOCKCHAIN_RPC=${RPC_URL}
      - SERVER_ID=1
    ports:
      - "3001:3001"
    volumes:
      - ./data:/data
      - ./keys:/keys
```

**Characteristics:**
- 1-of-1 threshold configuration
- No coordination overhead
- Instant operations
- Suitable for prototyping

</TabItem>
<TabItem value="multi" label="Multi-Server (Production)">

Production-ready distributed deployment:

```yaml
# docker-compose.yml for multi-server setup
version: '3.8'
services:
  neuralock-server-1:
    image: neuralock/server:latest
    environment:
      - MODE=production
      - THRESHOLD=3
      - TOTAL_SERVERS=5
      - SERVER_ID=1
      - IMPORTANCE_FACTOR=1.0
    networks:
      - neuralock-network
    
  neuralock-server-2:
    image: neuralock/server:latest
    environment:
      - MODE=production
      - THRESHOLD=3
      - TOTAL_SERVERS=5
      - SERVER_ID=2
      - IMPORTANCE_FACTOR=1.0
    networks:
      - neuralock-network
  
  # ... servers 3-5 ...

networks:
  neuralock-network:
    driver: overlay
    encrypted: true
```

**Characteristics:**
- k-of-n threshold (e.g., 3-of-5)
- Geographic distribution support
- Fault tolerance
- Load balancing

</TabItem>
</Tabs>

### 3. Client SDKs

Client SDKs abstract the complexity of threshold cryptography and provide simple interfaces for developers.

#### SDK Architecture

<CodeBlock language="typescript">
{`// Core SDK architecture
export class NeuralockClient {
  private servers: ServerEndpoint[];
  private threshold: number;
  private crypto: CryptoEngine;
  private session: Session | null;
  
  constructor(config: NeuralockConfig) {
    this.servers = config.servers;
    this.threshold = config.threshold;
    this.crypto = new CryptoEngine();
    this.session = null;
  }
  
  async createSession(signer: Signer): Promise<void> {
    // 1. Generate ephemeral keypair
    const ephemeralKey = this.crypto.generateKeypair();
    
    // 2. Create signed message
    const message = this.createSessionMessage(ephemeralKey.publicKey);
    const signature = await signer.signMessage(message);
    
    // 3. Register with all servers
    const promises = this.servers.map(server =>
      server.createSession(message, signature, ephemeralKey.publicKey)
    );
    
    const results = await Promise.allSettled(promises);
    const successful = results.filter(r => r.status === 'fulfilled');
    
    if (successful.length < this.threshold) {
      throw new Error('Insufficient servers available');
    }
    
    this.session = {
      id: successful[0].value.sessionId,
      ephemeralKey,
      activeServers: successful.map(r => r.value.serverId)
    };
  }
}`}</CodeBlock>

#### Language Support

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
  <Card>
    <CardHeader>
      <CardTitle>JavaScript/TypeScript SDK</CardTitle>
    </CardHeader>
    <ul>
      <li>Full TypeScript support</li>
      <li>React hooks for easy integration</li>
      <li>Browser and Node.js compatible</li>
      <li>WebCrypto API usage</li>
    </ul>
    <CodeBlock language="bash">
{`npm install @neuralock/sdk`}
    </CodeBlock>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Python SDK</CardTitle>
    </CardHeader>
    <ul>
      <li>Async/await support</li>
      <li>Type hints throughout</li>
      <li>Integration with popular frameworks</li>
      <li>Native cryptography libraries</li>
    </ul>
    <CodeBlock language="bash">
{`pip install neuralock-sdk`}
    </CodeBlock>
  </Card>
</div>

### 4. Management Portal

The NFT Management Portal provides a web-based interface for system administration.

#### Portal Features

<Features>
  <Feature 
    icon="ðŸŽ›ï¸" 
    title="Server Management" 
    description="Register new servers, update metadata, manage NFTs"
  />
  <Feature 
    icon="ðŸ‘¥" 
    title="Role Administration" 
    description="Assign and revoke admin/manager roles"
  />
  <Feature 
    icon="ðŸ“ˆ" 
    title="Analytics Dashboard" 
    description="Monitor system health, usage metrics, and performance"
  />
  <Feature 
    icon="ðŸ”" 
    title="Audit Logs" 
    description="Track all administrative actions and access patterns"
  />
  <Feature 
    icon="âš™ï¸" 
    title="Configuration" 
    description="Adjust threshold settings and importance factors"
  />
  <Feature 
    icon="ðŸš¨" 
    title="Alerts" 
    description="Real-time notifications for security events"
  />
</Features>

### 5. Cryptographic Layer

The cryptographic layer implements the core security primitives.

#### Cryptographic Flow

<CodeBlock language="typescript">
{`// Encryption process
async function encrypt(data: Uint8Array, servers: Server[]): Promise<EncryptResult> {
  // 1. Generate AES key
  const aesKey = await crypto.generateKey(
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt']
  );
  
  // 2. Encrypt data
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await crypto.encrypt(
    { name: 'AES-GCM', iv },
    aesKey,
    data
  );
  
  // 3. Export AES key
  const keyBytes = await crypto.exportKey('raw', aesKey);
  
  // 4. Split key using Shamir's Secret Sharing
  const shares = shamirSplit(keyBytes, threshold, servers.length);
  
  // 5. Encrypt each share for its respective server
  const encryptedShares = await Promise.all(
    shares.map(async (share, i) => {
      const serverPublicKey = servers[i].encryptionPublicKey;
      const encryptedShare = await ecdhEncrypt(share, serverPublicKey);
      return { serverId: servers[i].id, share: encryptedShare };
    })
  );
  
  return { ciphertext, iv, encryptedShares };
}`}</CodeBlock>

#### Security Primitives

| Component | Algorithm | Purpose |
|-----------|-----------|---------|
| Server Identity | secp256k1 | Blockchain compatibility |
| Key Agreement | X25519 ECDH | Fast, secure key exchange |
| Symmetric Encryption | AES-256-GCM | Data encryption with authentication |
| Secret Sharing | Shamir's SSS | Threshold key distribution |
| Hashing | SHA-256 | Integrity verification |
| Key Derivation | HKDF | Secure key expansion |

## Data Flow

### Encryption Flow

<CodeBlock language="text">
{`1. Client generates AES-256 key
   â””â”€> Encrypts user data
   
2. AES key split into n shares
   â””â”€> Using Shamir's Secret Sharing
   
3. Each share encrypted with server's public key
   â””â”€> Using ECDH key agreement
   
4. Encrypted shares sent to servers
   â””â”€> Servers verify permissions on-chain
   
5. Servers store encrypted shares
   â””â”€> Return confirmation to client`}</CodeBlock>

### Decryption Flow

<CodeBlock language="text">
{`1. Client requests shares from k servers
   â””â”€> Includes session ID and object ID
   
2. Servers verify read permissions
   â””â”€> Check smart contract on blockchain
   
3. Servers re-encrypt shares for session
   â””â”€> Using session's ephemeral key
   
4. Client receives k encrypted shares
   â””â”€> Decrypts using ephemeral private key
   
5. Client reconstructs AES key
   â””â”€> Using Lagrange interpolation
   
6. Client decrypts original data
   â””â”€> Using reconstructed AES key`}</CodeBlock>

## Security Architecture

### Defense in Depth

<Callout type="info">
  Neuralock implements multiple layers of security to protect against various attack vectors.
</Callout>

1. **Network Security**
   - TLS 1.3 for all communications
   - Certificate pinning for server verification
   - Rate limiting and DDoS protection

2. **Cryptographic Security**
   - End-to-end encryption
   - Perfect forward secrecy
   - Constant-time implementations

3. **Access Control**
   - On-chain permission verification
   - Time-limited sessions
   - Role-based administration

4. **Operational Security**
   - Secure key generation and storage
   - Regular security audits
   - Incident response procedures

### Threat Mitigation

| Threat | Mitigation |
|--------|------------|
| Server Compromise | Threshold design ensures k servers needed |
| Network Interception | End-to-end encryption with ECDH |
| Replay Attacks | Timestamps and nonces in all requests |
| Permission Escalation | Immutable on-chain verification |
| DoS Attacks | Rate limiting and distributed architecture |
| Key Exposure | Ephemeral sessions and key rotation |

## Performance Characteristics

### Latency Analysis

<Tabs>
<TabItem value="single" label="Single Server">

**Typical latencies:**
- Session creation: 50-100ms
- Encryption: 20-50ms
- Decryption: 20-50ms

**Factors:**
- No coordination overhead
- Single network hop
- Direct blockchain queries

</TabItem>
<TabItem value="multi" label="Multi-Server">

**Typical latencies:**
- Session creation: 200-500ms
- Encryption: 100-300ms
- Decryption: 150-400ms

**Factors:**
- Parallel server requests
- Geographic distribution
- Consensus requirements

</TabItem>
</Tabs>

### Scalability Considerations

1. **Horizontal Scaling**
   - Add servers without protocol changes
   - Increase redundancy and availability
   - Geographic distribution for lower latency

2. **Vertical Scaling**
   - Increase server capacity
   - Optimize cryptographic operations
   - Cache blockchain queries

3. **Storage Scaling**
   - Sharded storage across servers
   - Archival strategies for old shares
   - Compression for large objects

## Integration Patterns

### Microservices Architecture

<CodeBlock language="yaml">
{`# Example Kubernetes deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neuralock-server
spec:
  replicas: 5
  selector:
    matchLabels:
      app: neuralock-server
  template:
    metadata:
      labels:
        app: neuralock-server
    spec:
      containers:
      - name: server
        image: neuralock/server:latest
        env:
        - name: SERVER_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: THRESHOLD
          value: "3"
        - name: TOTAL_SERVERS
          value: "5"
        ports:
        - containerPort: 3001
        volumeMounts:
        - name: keys
          mountPath: /keys
          readOnly: true
      volumes:
      - name: keys
        secret:
          secretName: neuralock-keys`}</CodeBlock>

### API Gateway Integration

<CodeBlock language="typescript">
{`// Express middleware for Neuralock integration
export const neuralockMiddleware = (client: NeuralockClient) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      // Extract session from headers
      const sessionId = req.headers['x-neuralock-session'];
      
      // Verify session is active
      if (!await client.verifySession(sessionId)) {
        return res.status(401).json({ error: 'Invalid session' });
      }
      
      // Attach client to request
      req.neuralock = client;
      next();
    } catch (error) {
      res.status(500).json({ error: 'Neuralock error' });
    }
  };
};`}</CodeBlock>

## Next Steps

Now that you understand the architecture, explore:

- **[How It Works](/neuralock/overview/how-it-works)** - Detailed protocol walkthrough
- **[Key Features](/neuralock/overview/key-features)** - Core capabilities and benefits
- **[Quick Start Guide](/neuralock/getting-started/quick-start)** - Begin implementation